///////////////////////////////////////////////////////////////
//
//  Dual LFO
//
//  Two channels of control voltages generated by an Arduino via PWM
//
//  There are several controls and LEDs referenced in this sketch:
//
//    1 Momentary switch for changing modes (single down/up increments mode)
//    2 LEDS make up an LED Bar displaying the current mode
//
//    1 Momentary switch and two 10k potentiometers for each LFO:
//      The switch increments through different wave tables
//      One potentiometer is for LFO frequency
//      One potentiometer is for LFO depth
//
//    1 Momentary switch as a sync "trigger" which restarts the LFOs at zero
//
//  Finally, the LFO outputs are on pins 3 and 11. Since the output is PWM, it's 
//  important to add low-pass filters to these pins to smooth out the resulting waveform
//
//  See accompanying Fritzing documents for circuit information.
//
//  The MIT License (MIT)
//  
//  Copyright (c) 2013-2018 Robert W. Gallup (www.robertgallup.com)
//  
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
// 

#include "Settings.h"

// Control Framework
#include "src/CS_Led.h"
#include "src/CS_LEDBar.h"
#include "src/CS_Pot.h"
#include "src/CS_Switch.h"

// Waves
#include "wave/noise256.h"
#include "wave/ramp256.h"
#include "wave/saw256.h"
#include "wave/sine256.h"
#include "wave/tri256.h"
#include "wave/pulse8.h"
#include "wave/pulse16.h"
#include "wave/pulse64.h"
#include "wave/sq256.h"

// Macros for clearing and setting bits
#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))

// Trigger initial state:
int triggerInitState;

// I/O Devices

// Mode Display (2 LEDs)
#if defined(LEDMODEDISPLAY)
CS_LEDBar    modeDisplay(MODE_DISPLAY_PIN, NUM_MODE_DISPLAY_PINS);
#endif

// Mode Switch
CS_Switch    modeSwitch(MODE_SWITCH_PIN);

CS_Pot       LFO1_DepthKnob (DEPTH_KNOB1_PIN);
CS_Pot       LFO1_FreqKnob (FREQ_KNOB1_PIN);
CS_Switch    LFO1_WaveSwitch(WAVE_SWITCH1_PIN);

CS_Pot       LFO2_DepthKnob (DEPTH_KNOB2_PIN);
CS_Pot       LFO2_FreqKnob (FREQ_KNOB2_PIN);
CS_Switch    LFO2_WaveSwitch (WAVE_SWITCH2_PIN);

// Trigger (deactivate the internal pullup resistor)
CS_Switch    triggerSwitch(TRIGGER_PIN, false);

// Interrupt frequency (16,000,000 / 510)
// 510 is divisor rather than 512 since with phase correct PWM
// an interrupt occurs after one up/down count of the register
// See: https://www.arduino.cc/en/Tutorial/SecretsOfArduinoPWM
const float clock = 31372.5;

// LFO Wave Table Numbers
byte LFO1_WaveTableNum = 0;
byte LFO2_WaveTableNum = 0;

// Wave table pointers
byte *waveTables[] = {sine256, ramp256, saw256, tri256, pulse8, pulse16, pulse64, sq256, noise256};
#define NUM_WAVES (sizeof(waveTables) / sizeof(byte *))

// Interrupt vars are volatile
volatile byte tickCounter;               // Counts interrupt "ticks". Reset every 125  
volatile byte fourMilliCounter;          // Counter incremented every 4ms

volatile unsigned long LFO1_Offset=0;    // LFO1 offset
volatile          int  LFO1_Direction=1; // -1 if the wave is inverted
volatile unsigned long accumulatorA;     // Accumulator LFO1
volatile unsigned long LFO1_TuningWord;  // Frequency DDS tuning
volatile unsigned long LFO1_Depth;       // Frequency voltage depth
volatile byte offsetA;                   // Wave table offset

volatile unsigned long LFO2_Offset=0;    // LFO2 Offset
volatile          int  LFO2_Direction=1; // -1 if the wave is inverted
volatile unsigned long accumulatorB;     // Accumulator LFO2
volatile unsigned long LFO2_TuningWord;  // Volume DDS tuning
volatile unsigned long LFO2_Depth;       // Volume voltage depth
volatile byte offsetB;                   // Wave table offset

volatile byte *LFO1_WaveTable;
volatile byte *LFO2_WaveTable;

volatile byte mode = 0;

void setup()
{


  // PWM Pins
  pinMode(LFO1_OUTPUT_PIN, OUTPUT);     // pin11= PWM:A
  pinMode(LFO2_OUTPUT_PIN, OUTPUT);     // pin 3= PWM:B

  // Trigger Pin (get initial state for reference)
  pinMode(TRIGGER_PIN, INPUT);
  triggerInitState = triggerSwitch.stateDebounced();

#if defined(LEDMODEDISPLAY) && defined(STARTUPEYECANDY)

  // Startup eye-candy
  byte candy = 1;
  while (modeSwitch.stateDebounced() == 1) {
    modeDisplay.displayNum(candy);
    candy = 3 - candy;
    delay (100);
  }
  modeDisplay.displayNum(mode);
  while (modeSwitch.stateDebounced() == 0){
  };

#endif

  // Initialize timers
  Setup_timer2();

  // Initialize wave tables
  LFO1_WaveTable = waveTables[0];
  LFO2_WaveTable = waveTables[0];
  
  // Initialize switch states
  while (modeSwitch.stateDebounced()==0);
  while (LFO1_WaveSwitch.stateDebounced()==0);
  while (LFO2_WaveSwitch.stateDebounced()==0);

}
void loop()
{
  while(1) {

    if (fourMilliCounter > 25) {                 // Every 1/10 second
      fourMilliCounter=0;

      // Check trigger. If pulsed, reset wave pointers:
      byte switchState = triggerSwitch.stateDebounced();
      if (switchState != triggerInitState) {
        accumulatorA = 0;
        accumulatorB = 0;
      }

      // Check performance mode
      switchState = modeSwitch.stateDebounced();
      if (modeSwitch.changed()) {
        if (switchState == 1) {
          mode = (mode+1) % NUM_PERFORMANCE_MODES;
          switch (mode) {
            
            // Both LFO in normal phase
            case PM_NORMAL:
              LFO1_Offset = 0;
              LFO1_Direction = 1;
              LFO2_Offset = 0;
              LFO2_Direction = 1;
              break;
              
            // LFO1 Inverted
            case PM_INVERT1:
              LFO1_Offset = 255;
              LFO1_Direction = -1;
              LFO2_Offset = 0;
              LFO2_Direction = 1;
              break;
              
            // LFO2 Inverted
            case PM_INVERT2:
              LFO1_Offset = 0;
              LFO1_Direction = 1;
              LFO2_Offset = 255;
              LFO2_Direction = -1;
              break;

            // Both LFO1 and LFO2 Inverted
            case PM_INVERTALL:
              LFO1_Offset = 255;
              LFO1_Direction = -1;
              LFO2_Offset = 255;
              LFO2_Direction = -1;
              break;
              
            // Both LFO in normal phase
            default:
              LFO1_Offset = 0;
              LFO1_Direction = 1;
              LFO2_Offset = 0;
              LFO2_Direction = 1;

          }
        }
#if defined(LEDMODEDISPLAY)
        modeDisplay.displayNum(mode);
#endif
      }

      // LFO 1 wave table
      switchState = LFO1_WaveSwitch.stateDebounced();
      if (LFO1_WaveSwitch.changed()) {
        if (switchState == 1) {
          LFO1_WaveTableNum = (LFO1_WaveTableNum + 1) % NUM_WAVES;
          LFO1_WaveTable = waveTables[LFO1_WaveTableNum];
        }
      }

      // LFO 2 wave table
      switchState = LFO2_WaveSwitch.stateDebounced();
      if (LFO2_WaveSwitch.changed()) {
        if (switchState == 1) {
          LFO2_WaveTableNum = (LFO2_WaveTableNum + 1) % NUM_WAVES;
          LFO2_WaveTable = waveTables[LFO2_WaveTableNum];
        }
      }

      // LFO 1
      LFO1_TuningWord = pow(1.02, LFO1_FreqKnob.value()) + 8192;
      LFO1_Depth  = LFO1_DepthKnob.value();

      // LFO 2
      LFO2_TuningWord = pow(1.02, LFO2_FreqKnob.value()) + 8192;
      LFO2_Depth  = LFO2_DepthKnob.value();
    }

  }
}

//******************************************************************
// timer2 setup
void Setup_timer2() {

  // Prescaler 1
  sbi (TCCR2B, CS20);
  cbi (TCCR2B, CS21);
  cbi (TCCR2B, CS22);

  // Non-inverted PWM
  cbi (TCCR2A, COM2A0);
  sbi (TCCR2A, COM2A1);
  cbi (TCCR2A, COM2B0);
  sbi (TCCR2A, COM2B1);

  // Phase Correct PWM
  sbi (TCCR2A, WGM20);
  cbi (TCCR2A, WGM21);
  cbi (TCCR2B, WGM22);

  // Enable interrupt
  sbi (TIMSK2,TOIE2);
  
}

////////////////////////////////////////////////////////////////
//
// Timer2 Interrupt Service
// Frequency = 16,000,000 / 510 = 31372.5
//
ISR(TIMER2_OVF_vect) {
  unsigned long temp;

  // Count every four milliseconds
  if(tickCounter++ == 125) {
    fourMilliCounter++;
    tickCounter=0;
  }   

  // Sample wave table for LFO1
  accumulatorA  += LFO1_TuningWord;
  offsetA        = accumulatorA >> 24; // high order byte
  temp           = pgm_read_byte_near(LFO1_WaveTable + offsetA);
  temp           = ((LFO1_Offset + (LFO1_Direction * temp)) * LFO1_Depth) / 1024;
  OCR2A          = (temp > 255) ? 255 : temp;

  // Sample wave table for LFO2
  accumulatorB  += LFO2_TuningWord;
  offsetB        = accumulatorB >> 24; // high order byte
  temp           = pgm_read_byte_near(LFO2_WaveTable + offsetB);
  temp           = ((LFO2_Offset + (LFO2_Direction * temp)) * LFO2_Depth) / 1024;
  OCR2B          = (temp > 255) ? 255 : temp;
  
}
